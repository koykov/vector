# Vector API

Описывает API для векторных парсеров.

Главная идея: популярные форматы обмена данными (такие как JSON, XML, ...) хранят данные в виде дерева. А все популярные
парсеры воспроизводят это дерево в памяти приложения. Более того, они создают копию исходных данных внутри себя и это
приводит к перерасходу памяти. В комплексе это приводит к тому, что в памяти накапливается большое количество
указателей и GC делает много дополнительной работы при маркировке.

Этот парсер действует иначе: любые ноды (объект, массив, пары ключ-значение, ...) хранятся не в дереве, а в специальном
массиве (векторе). Вместо указателей на дочерние ноды используются индексы дочерних нод в векторе, иными словами каждая
нода хранит список смежности дочерних нод. В реальности всё несколько иначе: список индексов дочерних нод хранится не
внутри самой ноды (чтобы не плодить указатели), а в специальной структуре Index, это будет рассмотрено далее.

Таким образом главная главная цель всего проекта заключается в том, чтобы минимизировать количество указателей в памяти,
и, тем самым, сократить издержки на работу GC. Дополнительной целью является минимизация использования памяти.

Сравним эти два подхода на конкретном примере. Пусть мы имеем JSON документ:
```json
{
  "a":{"c":"foobar","d":3.1415},
  "b":["asdfgh","zxcvb"]
}
```

Типичный парсер создаст в памяти дерево вида:
<img width="100%" src="static/typical.svg" alt="">

, где каждый узел будет являться структурой:
```go
type Node struct {
	typ Type    // [null, object, array, string, number, true, false]
	obj Object  // one pointer to slice and N*2 pointers inside KeyValue struct, see below
	arr []*Node // one pointer for the slice and N pointers for each array item
	str string  // one pointer
}

type Object []KeyValue

type KeyValue struct {
	key string // one pointer
	val *Node  // one pointer to node
}
```

Нетрудно заметить, что такая структура плодит чересчур много указателей и с ростом сложности исходного документа их будет
всё больше.

Вектор в пямяти будет выглядеть следующим образом:
<img width="100%" src="static/vector-color.svg" alt="">

Выглядит громоздко и странно, не так ли? Но такая структура позволяет для любого варианта исходных данных иметь всего
несколько указателей в векторе:
* один на сам массив (вектор) нод
* один на индекс
* плюс по одному на каждую строку в индексе

Таким образом если считать "сложность структуры по указателям", то она будет константной, в то время как у классических
парсеров, она будет в лучшем случае линейной.

В действительности структура нод вектора сложнее чем представленная на диаграмме. Ключ/значение являются не числом, где
с помощью побитовых сдвигов хранятся lo/hi индексы в исходных данных, а структурой [Byteptr](byteptr.go). Она позволяет
хранить не только lo/hi индексы, но и raw (uintptr) указатели на данные и дополнительные флаги. Но суть остаётся
неизменной: с точки зрения GC, что byteptr, что нода это просто структура без всяких указателей и он не будет тратить
время на их проверку.
